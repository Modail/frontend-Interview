#### OSI七层模型和(五层模型)和TCP/IP模型
4、传输层：是参考模型的第四层。主要功能是：向用户提供可靠地端到端服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。
OSI                                                                                                                       TCP/IP
应用层：提供应用进程所需要信息交换和远程操作，而且还要作为应用进程的用户代理，完成一些为进行语义上有意义的信息交换所必须的功能。
协议（HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP）          
表示层---五层模型并入应用层  用于处理两个通信系统间信息交换的表示方式，它包括数据格式变换、数据加密与解密、数据压缩与恢复等功能。
会话层---五层模型并入应用层  组织同步的两个会话用户之间的对话,并管理数据的交换                                                   应用层
传输层： 向用户提供可靠地端到端服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。协议(tcp、udp)                                                                                                                     传输层
网络层： 为数据在节点之间传输创建逻辑链路，通过路由选择算法为分组通过通信子网选择最适当的路径，
以及实现拥塞控制、网络互连等功能。协议（icmp、ip等、交换机、路由器）                                                             网络层
数据链路层：
在物理层提供比特流传输服务的基础上，在通信实体之间建立数据链路连接，传送以帧为单位的数据，
通过差错控制、流量控制方法，变有差错的物理线路为无差错的数据链路。
物理层： 利用物理传输介质为数据链路层提供物理连接，以透明地传送比特流                                                           网络接口层
#### 谈一谈tcp和udp
          UDP	                                        TCP
是否连接	无连接	                                      面向连接
是否可靠	不可靠传输，不使用流量控制和拥塞控制	          可靠传输，使用流量控制和拥塞控制
连接对象个数	支持一对一，一对多，多对一和多对多交互通信	  只能是一对一通信
传输方式	面向报文	                                    面向字节流
首部开销	首部开销小，仅8字节	                          首部最小20字节，最大60字节
适用场景	适用于实时应用（IP电话、视频会议、直播等）	     适用于要求可靠传输的应用，例如文件传输

udp攻击手段：udp-flood 因为udp是无状态的，可以发送大量udp包到某端口，以达到干扰应用运行、占用服务器资源、占用带宽（因为服务器要回传给icmp处理）的目的
tcp攻击手段：syn-flood 不断发送tcp syn报文，因为端口等待建立连接的请求数量有一个阙值，到达后将丢弃后面的报文，导致其他用户无法连接。
tcp会话劫持：

#### tcp 三次握手 四次挥手   syn：同步序列号
三次握手
　　第一次握手：主机A发往主机B，主机A的初始序号是X，设置SYN位，未设置ACK位
　　第二次握手：主机B发往主机A，主机B的初始序号是Y，确认号(ACK)是X+1，X+1确认号暗示己经收到主机A发往主机B的同步序号。设置SYN位和ACK位
　　第三次握手：主机A发往主机B，主机A的序号是X+1，确认号是Y+1，Y+1确认号暗示已经收到主机B发往主机A的同步序号。设置ACK位，未设置SYN位
　　三次握手解决的不仅仅有序号问题，还解决了包括窗口大小、MTU(Maximum Transmission Unit,最大传输单元)，以及所期望的网络延时等其他问题
四次挥手
TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。
第一次挥手
若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
第二次挥手
B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。
第三次挥手
B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。
第四次挥手
A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。

#### tcp keepalive
+ 起源：TCP协议中有长连接和短连接之分。
短连接环境下，数据交互完毕后，主动释放连接；
长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了TCP的Keepalive（保活探测）机制。
应用层上的解决方案是心跳包
+ 作用：1.探测连接的对端是否存活  利用保活探测功能，可以探知这种对端的意外情况，从而保证在意外发生时，可以释放半打开的TCP连接。
      2.防止中间设备（如防火墙）因超时删除连接相关的连接表
+ 缺点： 需要消耗额外的宽带和流量
+ 与http keep-alive的关系：HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；TCP的Keepalive机制意图在于探测连接的对端是否存活。
#### tcp 滑动窗口

#### ip地址的分类、划分方法
划分方法：
1.分类：
IP地址:: = {<网络号>，<主机号>}
不同的网络号和主机号的设置决定了IP地址的分类，包括了A、B、C、D、E共5类。
A类地址：网络号8位（1个字节），主机号24位（3个字节），网络号的最高位到0即（01111111）
          0.0.0.0 ~ 127.255.255.255
B类地址：网络号16位（2个字节），主机号16位（2个字节），网络号的最高位到10即（10111111）
          128.0.0.0 ~ 191.255.255.255
C类地址：网络号24位（3个字节），主机号8位（1个字节），网络号的最高位到110即（11011111）
          192.0.0.0 ~ 223.255.255.255
D类地址：最高4位到1110即（11101111），用于IP多播
          224.0.0.0 ~ 239.255.255.255
E类地址：最高4位到1111即（11111111），作为保留使用
          240.0.0.0 ~ 255.255.255.255

2.子网划分
进行子网划分的原因：当我们对一个网络进行子网划分时，基本上就是将它分成小的网络。比如，当一组IP地址指定给一个公司时，公司可能将该网络“分割成”小的网络，每个部门一个。这样，技术部门和管理部门都可以有属于它们的小网络。通过划分子网，我们可以按照我们的需要将网络分割成小网络。这样也有助于降低流量和隐藏网络的复杂性。
IP地址:: = {<网络号>，<子网号>，<主机号>}
A类地址默认的子网掩码为255.0.0.0
B类地址默认的子网掩码为255.255.0.0
C类地址默认的子网掩码为255.255.255.0
例如一个B类IP为202.194.0.0均分给6个部门使用，求子网掩码、网络号、子网号、主机号？
①从202.194.0.0这个地址可以知道（网络号是202.194，则主机号是16位）
②因为23=8，所以需要从主机号借3位作子网号才能保证分出6子网，剩下的13位作为主机号，每个子网可容纳最大主机数213 - 2 = 8190个，减去网络地址和广播地址。
③子网号和主机号
202.194.0.0（子网号000）202.194.0.1~202.194.0.254（主机号）202.194.0.255（广播地址）
202.194.32.0（子网号001）202.194.32.1~202.194.32.254（主机号）202.194.32.255（广播地址）
202.194.64.0（子网号010）202.194.64.1~202.194.64.254（主机号）202.194.64.255（广播地址）
202.194.96.0（子网号011）202.194.96.1~202.194.96.254（主机号）202.194.96.255（广播地址）
202.194.128.0（子网号100）202.194.128.1~202.194.128.254（主机号）202.194.128.255（广播地址）
202.194.160.0（子网号101）202.194.160.1~202.194.160.254（主机号）202.194.160.255（广播地址）
202.194.192.0（子网号110）202.194.192.1~202.194.192.254（主机号）202.194.192.255（广播地址）
202.194.224.0（子网号111）202.194.224.1~202.194.224.254（主机号）202.194.224.255（广播地址）
④主机号借了3位，子网掩码为11111111.11111111.11100000.00000000即255.255.224.0  

3.无分类编址CIDR
IP地址:: = {<网络前缀>，<主机号>}
例如202.194.20.138/19，此IP中前19位为网络前缀，后13位为主机号。
①202.194.20.138/19用二进制表示为：
11001010  11000010  00010100  1000101
②该地址所在CIDR地址块中最小的地址为
11001010  11000010  00000000  00000000，即202.194.0.0
③该地址所在CIDR地址块中最大的地址为：
11001010  11000010  00011111  11111111，即202.194.31.255
④该地址块中共有213=8192个地址
⑤/19对应的子网掩码为11111111.11111111.11100000.00000000，即255.255.224.0    

#### ipv4和ipv6
+ 地址长度
IPv4协议具有32位（4字节）地址长度；IPv6协议具有128位（16字节）地址长度
+ 地址的表示方法
IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。
IPV4：192.168.0.1   IPV6: FDEC:.......:FFFF
+ 安全性
ipv4的IPSec（IP Security）是可选和付费的，ipv6是内置的。

#### http和https
https =http+ssl
+ HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
+ 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
+ HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
+ http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。
https实现过程：
1.客户端发起https请求，连接server端的443端口；
2.server有ca证书，传输证书（即公钥，有一些证书信息）；非对称加密
3.客户端TSL/SSL解析证书,检验证书的合法性，证书有效，客户端生成一个随机值，并且用公钥加密。对称加密
4.传输加密信息 即传输随机值（客户端私钥）
5.server端用自己的私钥解密随机值，并用这个随机值加密信息进行传递
6.传输加密信息
7.客户端用之前的随机值进行解密，获得信息。

#### http1.0、http1.1、http2
http1.0和http1.1的区别：
+ 缓存处理   在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
+ 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
+ 错误通知的管理   在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
+ Host头处理    在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
+ 长连接  HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

http2.0 和http1.x的区别：
+ 头部压缩  HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value在两端建立一个索引表，对相同的头只发送索引表中的索引。
+ 多路复用  HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实只是一个虚拟的通道。流是有优先级的。
+ 二进制分帧 HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有Header 帧，用于传输 Header 内容，并且会开启一个新的流。再就是Data 帧，用来传输正文实体。多个 Data 帧属于同一个流
+ serverpush 当一个客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器可以在客户端发送请求前，主动将资源Z推送给客户端。优化响应速度

#### HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？
HTTP/1.0 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

#### 常见 HTTP 状态码
| 状态码               | desc          | 状态                             | 备注 |
| -------------------- | ------------- | -------------------------------- | ---- |
| 1xx 信息性状态码     | Informational | 服务器正在处理数据               |      |
| 2xx 成功状态码       | Success       | 请求已正常处理完毕               |      |
| 3xx 重定向状态码     | Redirection   | 需要进行额外操作以完成请求       |      |
| 4xx 客户端错误状态码 | Client Error  | 客户端原因导致服务器无法处理请求 |      |
| 5xx 服务器错误状态码 | Server Error  | 服务器原因导致处理请求出错       |      |

2xx 成功

| 状态码 | desc            | 状态                             | 备注                 |
| ------ | --------------- | -------------------------------- | -------------------- |
| 200    | ok              | 请求被服务器正常处理             |                      |
| 202    | Accepted        | 已收到请求消息，但是尚未进行处理 |                      |
| 204    | Not Content     | 请求已正常处理，但是没有内容返回 |                      |
| 206    | Partial Content | 服务器已经完成了部分 GET 请求    | 这个和断点续传有关系 |

3xx 重定向

| 状态码 | desc              | 状态                                               | 备注 |
| ------ | ----------------- | -------------------------------------------------- | ---- |
| 301    | moved permanently | 永久重定向                                         |      |
| 302    | found             | 临时重定向                                         |      |
| 303    | see other         | 请求资源存在另一个 URI,应使用 GET 定向获取请求资源 |      |
| 304    | Not Modified      | 表示客户端发送附带条件的请求时，条件不满足         | 协商缓存 由服务端检验     |

4xx 客户端错误

| 状态码 | desc         | 状态                                           | 备注 |
| ------ | ------------ | ---------------------------------------------- | ---- |
| 400    | bad request  | 请求报文存在语法错误或参数错误，服务器不理解   |      |
| 401    | Unauthorized | 发送的请求需要有 HTTP 认证信息或者是认证失败了 |      |
| 403    | Forbidden    | 对请求资源的访问被服务器拒绝了                 |      |
| 404    | Not Found    | 表示服务器找不到你请求的资源                   |      |

5xx 服务器错误

| 状态码 | desc                  | 状态                           | 备注 |
| ------ | --------------------- | ------------------------------ | ---- |
| 500    | Internal Server Error | 表示服务器执行请求的时候出错了 |      |
| 502    | Bad Gateway           |                                |      |
| 503    | Service Unavailable   | 表示服务器超负载或正停机维护   |      |

#### 缓存机制
强制缓存：
结果：
（1）不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
（2）存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存（暂不分析）
（3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果
分析：
控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Conctrol的优先级比Expires高。
Expires是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间，即再次发送请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。HTTP/1.1，Expires已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，如果客户端与服务端的时间由于某些原因（时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存直接失效，那么强制缓存存在的意义就毫无意义。
Expires的值是一个绝对值，固定时间   Cache-Control的值由max-age确定，是个相对值

协商缓存：
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
（1）协商缓存生效，返回304
（2）协商缓存失败，返回200和请求结果
控制协商缓存的字段分别有：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。
+ Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间
+ If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件

+ Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
+ If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200
